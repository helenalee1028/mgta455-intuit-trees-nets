---
title: Intuit Trees and Nets
output: html_document
---

* Team-lead GitLab id:
* Group number:
* Group name:
* Team member names:

```{r r_setup, include = FALSE}
## initial settings
knitr::opts_chunk$set(
  comment = NA,
  echo = TRUE,
  error = TRUE,
  cache = FALSE,
  message = FALSE,
  dpi = 144,
  warning = FALSE
)

## width to use when printing tables etc.
options(
  width = 250,
  scipen = 100,
  max.print = 5000,
  stringsAsFactors = FALSE
)

## load radiant packages if needed
if (!exists("r_environment")) library(radiant)
```

<style>
.table {
  width: auto;
}
ul, ol {
  padding-left: 18px;
}
pre, code, pre code {
  overflow: auto;
  white-space: pre;
  word-wrap: normal;
  background-color: #ffffff;
}
</style>

## Setup

Please complete this R-markdown document with your group by working through the guidelines in `intuit-trees-nets.pdf` on Dropbox (week7/readings/). Create an HTML file with all your results and comments and push both the Rmarkdown and HTML file to GitLab when your team is done. All results MUST be reproducible (i.e., the TA and I must be able to recreate the HTML from the Rmarkdown file without changes or errors). Also, make sure the code is well commented and formatted (e.g., use styler through Addins > Style active file in Rstudio).

This is the second group assignment for MGTA 455 and you will be using git and GitLab. If two people edit the same file at the same time you could get what is called a "merge conflict". git will not decide for you who's change to accept so the team-lead will have to determine which edits to use. To avoid merge conflicts, always click "pull" in Rstudio before you start working on file. Then, when you are done, commit your changes, and push them to GitLab. Make this a habit!

If multiple people are going to work on the assignment at the same time I recommend you work on different files. You can use `source` to include R-code in your Rmarkdown document or include other R(markdown) documents into the main assignment file. 

Group work-flow tips are listed from ICT in summer are shown below:

* Pull, edit, save, stage, commit, and push
* Schedule who does what and when
* Try to avoid working simultaneously on the same file 
* If you are going to work simultaneously, do it in different files, e.g., 
    - assignment1_john.R, assignment1_susan.R, assignment1_wei.R 
    - assignment1a.R, assignment1b.R, assignment1c.R
* Use the 'source' command to bring different pieces of code together in an Rmarkdown document or in an R-code file
* Alternatively, use _child_ in Rmarkdown to include a part of a report
* For (very) big projects use 'branches' to avoid conflicts (and stay on your branch)

A graphical depiction of the group work-flow is shown below:

![](images/git-group-workflow.png)

Additional resource on the use of git are linked below:

* http://happygitwithr.com
* http://r-pkgs.had.co.nz/git.html
* http://stackoverflow.com/questions/tagged/git or just a google search
* https://try.github.io
* https://www.manning.com/books/git-in-practice
* https://github.com/GitInPractice/GitInPractice#readme


```{r}
## loading the data. Note that data must be loaded from the data/
## in the rstudio project directory
intuit75k <- readr::read_rds(file.path(radiant.data::find_dropbox(), "MGTA455-2019/data/intuit75k.rds"))
```

Below an example of how you could include another Rmd file inside your main assignment Rmarkdown document. Note:  don't add a YAML header to the _child_ file! 

```{r, child = "model1.Rmd"}
```

Alternatively you can source code from an .R file as follows:

```{r}
source("model1.R", local = TRUE)
```

Long running cross-validation should be put in a separate R-code file that can be sourced from the main Rmarkdown document. The code should **not** run by default when the TA or I knit your Rmarkdown document. The format should be like the code chunk below where we can soruce the cross-validation code if needed but by default just loads a data.frame from a file with the cross-validation results.

```{r}
# source("cross-validation-nn.R", local = TRUE)
load("data/cross-validation-results.rds")
```



### Evaluation metrics from last assginment, with logit regression 

```{r}
## loading the data. Note that data must be loaded from Dropbox/MGTA455-2019/data
intuit75k <- readr::read_rds(file.path(radiant.data::find_dropbox(), "MGTA455-2019/data/intuit75k.rds"))

## change variable types for 5 factor variables
intuit75k <- mutate_at(intuit75k, .vars = vars(zip_bins, bizflag, version1, owntaxprod, upgraded), .funs = funs(as_factor))

### create 00801 and 00804 bin

intuit75k <- intuit75k %>% 
  mutate(zip801 = ifelse(zip == "00801", "Yes", "No"),
         zip804 = ifelse(zip == "00804", "Yes", "No"))

intuit75k <- mutate_at(intuit75k, .vars = vars(zip801,zip804), .funs = funs(as_factor))

###split the data into train and test.

intuit75k_train <- intuit75k %>%
  filter(training == 1) 

intuit75k_test <- intuit75k %>%
  filter(training == 0)

```

#### Logistic Regression
```{r}

result <- logistic(
  intuit75k_train, 
  rvar = "res1", 
  evar = c(
    "zip_bins", "numords", "dollars", "last", 
    "version1", "owntaxprod", "upgraded", "zip801", "zip804"
  ), 
  lev = "Yes", 
  int = c("version1:last", "numords:version1")
)

pred <- predict(result, pred_data = intuit75k_test, conf = 0.9)

intuit75k_test$pred_logit_solution <- pred$Prediction
intuit75k_test$pred_logitlb <- pred$`5%`
```

#### Evaluation Functions
```{r}
cm <- function(dat, vars){
  
  cm_df <- as.data.frame(matrix(NA, ncol = 3, nrow = length(vars)))
  colnames(cm_df) <- c("var", "auc", "tpr")
  
  for (i in 1:length(vars)){
    
    var <- vars[i]
    probs <- pull(dat, !!var)
    resp <- pull(dat, "res1")
    
    mailto <- ifelse(pull(dat, !!var) > breakeven_rate, "TRUE", "FALSE") # decide whether to mail or not
    
    tpr <- sum(resp == "Yes" & mailto == "TRUE")/sum(resp == "Yes")
    auc <- ModelMetrics::auc(ifelse(resp=="Yes",1,0), probs)
    
    cm_vec <- c(var, auc, tpr)
    cm_df[i,] <- cm_vec
  }
  return(cm_df)
}

model_eval <- function(dat, vars){
  
  # calculate expected scaled profits and ROME
  
  eval_df <- as.data.frame(matrix(NA, ncol = 6, nrow = length(vars)))
  colnames(eval_df) <- c("var","nr_mail", "rep_rate_w2", "nr_resp_w2", "profit", "ROME")
  
  
  for (i in 1:length(vars)){
    
    var <- vars[i]
    
    mailto <- ifelse(pull(dat, !!var) > 2 * breakeven_rate, "TRUE", "FALSE") # decide whether to mail or not
    mailto_rate <- mean(mailto == "TRUE")
    nr_mail <- mailto_rate * (801821 - 38487) #target size
    
    resp <- pull(dat, "res1") # extract respondents
    
    rep_rate_w1 <- sum(resp == "Yes" & mailto == "TRUE")/sum(mailto=="TRUE") # response rate among targeted audience
    rep_rate_w2 <- rep_rate_w1 * 0.5
    nr_resp_w2 <- rep_rate_w2 * nr_mail # response customers among targeted audience
    
    sum_cost <- mail_cost * nr_mail
    revenue <- margin_revenue * nr_resp_w2
    profit <- revenue - sum_cost
    ROME <- profit/sum_cost
    
    perf_vec <- c(var, nr_mail, rep_rate_w2, nr_resp_w2, profit, ROME)
    
    eval_df[i,] <- perf_vec
  }
  
  return(eval_df) 
}


# this function is to plot cumulative gain and cumulative lift charts
lift_gain_plot <- function(dat, vars){
  
  lift_gain_df <- as.data.frame(matrix(NA, ncol = 4))
  colnames(lift_gain_df) <- c("resp_decile", "cumulative_gain", "cumulative_lift", "var")
  
  for (i in 1:length(vars)){
    
    var <- vars[i]
    
    probs <- pull(dat, !!var)
    resp <- pull(dat, "res1")
    
    lg_dat <- data.frame(probs, resp)
    lg_dat <- lg_dat %>% 
      mutate(resp_decile = xtile(probs, n = 10, rev = T)) %>% 
      group_by(resp_decile) %>% 
      summarise(n_customer = n(),
                n_buyer = sum(resp == "Yes")) %>%
      mutate(cum_customer = cumsum(n_customer),
             cum_buyer = cumsum(n_buyer),
             cumulative_lift = (cum_buyer/cum_customer)/overall_val_resp,
             cumulative_gain = cum_buyer/sum(n_buyer)) %>% 
      select(resp_decile, cumulative_gain, cumulative_lift)
    
    lg_dat[,var] <- var
    
    lift_gain_df <- rbind(lift_gain_df, setNames(lg_dat, names(lift_gain_df)))
  }
  
  lift_gain_df <- lift_gain_df[-1,] #remove first null row
  lift_gain_df$prop_customer <- rep(seq(0.1,1, 0.1),length(vars))
  
  # plot cumulative lift
  p1 <- lift_gain_df %>% 
    ggplot(aes(x = prop_customer, y = cumulative_lift, group = var)) + 
    geom_point(aes(color = var)) + geom_line(aes(color = var))+
    geom_hline(yintercept = 1, color = "black")
  
  
  
  # plot cumulative gain
  p2 <- lift_gain_df %>% 
    ggplot(aes(x = prop_customer, y = cumulative_gain, group = var)) + 
    geom_point(aes(color = var)) + geom_line(aes(color = var))+
    geom_line(aes(y = prop_customer), color = "black")
  
  gridExtra::grid.arrange(p1,p2, nrow = 2)
  
}


```

#### Compare the 2 predictions from last class

```{r fig.height=10}
mail_cost <- 1.41
margin_revenue <- 60
breakeven_rate <- mail_cost/margin_revenue

overall_val_resp <- mean(intuit75k_test$res1 == "Yes")

vars_vec <- c("pred_logit_solution", "pred_logitlb")
model_eval(intuit75k_test, vars_vec)

cm(intuit75k_test, vars_vec)

lift_gain_plot(intuit75k_test, vars_vec)

```

